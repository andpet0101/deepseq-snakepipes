# Workflow file do_mapping.snakemake
# ==================================

include: 'configuration/general.snakemake'
include: 'configuration/input.snakemake'
include: 'configuration/reference.snakemake'

##########
# Config #
##########

# snakemake_config.yml configuration lines (copy-and-paste and uncomment once)
#
#############
### mapping #
#############
##
### Mapping can be done with bwa, bwaaln, bwasw, bowtie1, bowtie2, gsnap, STAR. If preprocessing (remove adapter, process barcodes, etc.) has to be done before mapping 
### the files in the preprocessing directory will be used as input otherwise the files from the fastq directory. If the output of preprocessing is a BAM file with unaligned reads
### with additional tags/barcodes per read, then unaligned and aligned BAM file will be merged thus preserving the tags/barcodes. 
### 
##mapping:
##  program: bwa
### index: reference.version
### index_directory: /projects/seq-work/user/pipeline/bwa/
### binary: bwa
### extra:
### extra_aln:
### extra_samspe:
### tmp_dir: /tmp
### sort_by: coordinate
##

if not REFERENCE_CFG:
	raise WorkflowError('Please provide a reference configuration!')

MAPPING_CFG = config.get('mapping',dict())
if not MAPPING_CFG:
	raise WorkflowError('Please provide an aligner configuration!')
if "program" not in MAPPING_CFG:
	MAPPING_CFG["program"] = "gsnap"




MAPPING_CFG["program"] = "gsnap"


PROGRAM_CFG = dict()
PREPROCESSING_CFG = dict()
#PREPROCESSING_CFG = {'preprocessed_bams' : 1}

# function to define which input to use
def get_mapping_input_files(basename,preprocessing_cfg):
	if preprocessing_cfg:
		if 'preprocessed_bams' in preprocessing_cfg:
			return 'preprocessing/'+basename+'.unaligned.bam'
		else:
			return ['preprocessing/'+f for f in LIBRARIES[basename]['fastq']]
	else:
		return ['fastq/'+f for f in LIBRARIES[basename]['fastq']]

#########
# Rules #
#########

shell.prefix('set -euf -o pipefail;')


rule do_mapping:
	input:
		[MAPPING_CFG['program']+'/'+l+'.bam' for l in LIBRARIES.keys()],
		[MAPPING_CFG['program']+'/'+l+'.bai' for l in LIBRARIES.keys()]
	output:
		MAPPING_CFG['program']+'/'+'mapping.done'

rule run_samtools_index:
	input:
		'{program}/{basename}.bam'
	output:
		'{program}/{basename}.bai'
	log:
		'{program}/log/{basename}.bai.log'
	params:
		modules=PROGRAM_CFG
	wrapper:
		'wrappers/samtools/index'
	

rule run_bwa_mem:
	input:
		lambda wildcards: get_mapping_input_files(wildcards.basename,PREPROCESSING_CFG)
	output:
		bam='bwa/{basename}.bam'
	log:
		'bwa/log/{basename}.log'
	threads: 
		8
	params:
                readgroup=lambda wildcards: LIBRARIES[wildcards.basename]['readgroup'],
		library=lambda wildcards: LIBRARIES[wildcards.basename]['library'],
		sample=lambda wildcards: LIBRARIES[wildcards.basename]['sample'],
		paired_end=lambda wildcards: LIBRARIES[wildcards.basename]['paired-end'],
		index=MAPPING_CFG['index'] if 'index' in MAPPING_CFG else REFERENCE_CFG['version'],
		index_directory=MAPPING_CFG['index_directory'] if 'index_directory' in MAPPING_CFG else '/projects/seq-work/user/pipeline/bwa/',
		binary=MAPPING_CFG['binary'] if 'binary' in MAPPING_CFG else 'bwa',
		extra=MAPPING_CFG['extra'] if 'extra' in MAPPING_CFG else '-M',
		reference=REFERENCE_CFG['path']+'.fa',
		tmp_dir=MAPPING_CFG['tmp_dir'] if 'tmp_dir' in MAPPING_CFG else TMP_DIR,
		sort_by=MAPPING_CFG['sort_by'] if 'sort_by' in MAPPING_CFG else 'coordinate',
		modules=PROGRAM_CFG
	wrapper:
		'wrappers/bwa/mem'

rule run_bwa_aln:
	input:
		lambda wildcards: get_mapping_input_files(wildcards.basename,PREPROCESSING_CFG)
	output:
		bam='bwaaln/{basename}.bam'
	log:
		'bwaaln/log/{basename}.log'
	threads:
		8
	params:
                readgroup=lambda wildcards: LIBRARIES[wildcards.basename]['readgroup'],
		library=lambda wildcards: LIBRARIES[wildcards.basename]['library'],
		sample=lambda wildcards: LIBRARIES[wildcards.basename]['sample'],
		paired_end=lambda wildcards: LIBRARIES[wildcards.basename]['paired-end'],
		index=MAPPING_CFG['index'] if 'index' in MAPPING_CFG else REFERENCE_CFG['version'],
		index_directory=MAPPING_CFG['index_directory'] if 'index_directory' in MAPPING_CFG else '/projects/seq-work/user/pipeline/bwa/',
		binary=MAPPING_CFG['binary'] if 'binary' in MAPPING_CFG else 'bwa',
		extra_aln=MAPPING_CFG['extra_aln'] if 'extra_aln' in MAPPING_CFG else '',
		extra_samspe=MAPPING_CFG['extra_samspe'] if 'extra_samspe' in MAPPING_CFG else '',
		reference=REFERENCE_CFG['path']+'.fa',
		tmp_dir=MAPPING_CFG['tmp_dir'] if 'tmp_dir' in MAPPING_CFG else TMP_DIR,
		sort_by=MAPPING_CFG['sort_by'] if 'sort_by' in MAPPING_CFG else 'coordinate',
		modules=PROGRAM_CFG
		
	wrapper:
		'wrappers/bwa/aln'

rule run_bwa_sw:
	input:
		lambda wildcards: get_mapping_input_files(wildcards.basename,PREPROCESSING_CFG)
	output:
		bam='bwasw/{basename}.bam'
	log:
		'bwasw/log/{basename}.log'
	threads:
		8
	params:
                readgroup=lambda wildcards: LIBRARIES[wildcards.basename]['readgroup'],
		library=lambda wildcards: LIBRARIES[wildcards.basename]['library'],
		sample=lambda wildcards: LIBRARIES[wildcards.basename]['sample'],
		paired_end=lambda wildcards: LIBRARIES[wildcards.basename]['paired-end'],
		index=MAPPING_CFG['index'] if 'index' in MAPPING_CFG else REFERENCE_CFG['version'],
		index_directory=MAPPING_CFG['index_directory'] if 'index_directory' in MAPPING_CFG else '/projects/seq-work/user/pipeline/bwa/',
		binary=MAPPING_CFG['binary'] if 'binary' in MAPPING_CFG else 'bwa',
		extra=MAPPING_CFG['extra'] if 'extra' in MAPPING_CFG else '',
		reference=REFERENCE_CFG['path']+'.fa',
		tmp_dir=MAPPING_CFG['tmp_dir'] if 'tmp_dir' in MAPPING_CFG else TMP_DIR,
		sort_by=MAPPING_CFG['sort_by'] if 'sort_by' in MAPPING_CFG else 'coordinate',
		modules=PROGRAM_CFG
	wrapper:
		'wrappers/bwa/bwasw'

rule run_bowtie1:
	input:
		lambda wildcards: get_mapping_input_files(wildcards.basename,PREPROCESSING_CFG)
	output:
		bam='bowtie1/{basename}.bam'
	log:
		'bowtie1/log/{basename}.log'
	threads:
		8
	params:
	params:
                readgroup=lambda wildcards: LIBRARIES[wildcards.basename]['readgroup'],
		library=lambda wildcards: LIBRARIES[wildcards.basename]['library'],
		sample=lambda wildcards: LIBRARIES[wildcards.basename]['sample'],
		index=MAPPING_CFG['index'] if 'index' in MAPPING_CFG else REFERENCE_CFG['version'],
		index_directory=MAPPING_CFG['index_directory'] if 'index_directory' in MAPPING_CFG else '/projects/seq-work/user/pipeline/bowtie1/',
		binary=MAPPING_CFG['binary'] if 'binary' in MAPPING_CFG else 'bowtie1',
		extra=MAPPING_CFG['extra'] if 'extra' in MAPPING_CFG else '',
		tmp_dir=MAPPING_CFG['tmp_dir'] if 'tmp_dir' in MAPPING_CFG else TMP_DIR,
		sort_by=MAPPING_CFG['sort_by'] if 'sort_by' in MAPPING_CFG else 'coordinate',
		modules=PROGRAM_CFG
	wrapper:
		'wrappers/bowtie1'


rule run_gsnap:
	input:
		lambda wildcards: get_mapping_input_files(wildcards.basename,PREPROCESSING_CFG)

	output:
		bam='gsnap/{basename}.bam'
	log:
		'gsnap/log/{basename}.log'
	threads:
		8
	params:
                readgroup=lambda wildcards: LIBRARIES[wildcards.basename]['readgroup'],
		library=lambda wildcards: LIBRARIES[wildcards.basename]['library'],
		sample=lambda wildcards: LIBRARIES[wildcards.basename]['sample'],
		index=MAPPING_CFG['index'] if 'index' in MAPPING_CFG else REFERENCE_CFG['version'],
		index_directory=MAPPING_CFG['index_directory'] if 'index_directory' in MAPPING_CFG else '/projects/seq-work/user/pipeline/gmap/',
		binary=MAPPING_CFG['binary'] if 'binary' in MAPPING_CFG else 'gsnap',
		extra=MAPPING_CFG['extra'] if 'extra' in MAPPING_CFG else '',
		tmp_dir=MAPPING_CFG['tmp_dir'] if 'tmp_dir' in MAPPING_CFG else TMP_DIR,
		sort_by=MAPPING_CFG['sort_by'] if 'sort_by' in MAPPING_CFG else 'coordinate',
		modules=PROGRAM_CFG
	wrapper:
		'wrappers/gsnap'

	
